# 토스 | SLASH 24

## 오프닝 세션
> https://www.youtube.com/watch?v=xf4ddABhm4o

- 최고의 자율을 주어 도전을 하게 한다.
- 최복동 : 최고의 복지는 동료다


## 기반 데이터가 부족해도 OK! 커머스 추천 시스템 제작기
> https://www.youtube.com/watch?v=LAD6LYnkPsA

- MAB : Multi-armed Bandit
  : 이전까지 히스토리로 앞으로의 확률을 예측
- Serving Architecture
  - 많은 고객수, 빠른 반응성, 한정된 자원에서 효과적으로 서빙해야함
  - Batch Inference : 배치로 저장하고 사용자가 접근할때 제공
  - Real-time Inference : 사용자가 접근할때 실시간으로 제공
- 모델 학습 -> 서빙 -> 서비스 -> 로그 수집
- Batch Inference
  - 학습 / 배치 : 하둡, 스파크, 에어 플로우
  - 저장 / 관리 : 레디스 , 아파치 PHENIX
  - 추론 / 서빙 : Spring Boot, Java (보통 Python을 사용하나 JVM 환경 사용)
  - 사용자가 접근시, 아파치 PHENIX 에서 어떤 cohort 에 속하는지 확인하고, redis에서 데이터를 꺼내서 제공
  - 성능이 좋음, 10M Users, 50ms Latency
- Real-time Infrence
  - 학습 / 배치 : 하둡, 스파크, 에어 플로우
  - 저장 / 관리 : mlflow, toos feature store
  - 추론 / 서빙 : Spring boot, Java, ONNX RUNTIME
  - 데이터를 저장하기보다는 feature를 만드는데에 의미를 둠
  - 사용자가 접근시, 사용자의 feature를 feature store에서 가져오고, 모델을 통해 feature를 분석하여 실시간으로 추론하여 추천 제공
  - 10M users, 100ms Latency

## 리플레이 검증으로 새로운 금융 시스템 안전하게 도입하기
> https://www.youtube.com/watch?v=D3p-V5Sr7gk

###국내원장 차세대 프로젝트 : C언어 Monolithic 원장 => Kotlin 기반 MSA 원장
- 제약사항 : API 스펙 유지, DB 스키마 유지, 주요 비즈니스 로직 유지
- 어려움 : 기존 시스템의 변경, 테스트 코드를 작성하기엔 부족한 리소스, 한번의 통합 테스트를 위해 필요한 많은 선행 작업들
- 배포 -> 테스트 -> 검증 및 확인 -> 수정 사이클로 진행
  => 테스트 -> 검증 및 확인 자동화
- Read Verifier : READ API 검증 자동화, API 호출을 비동기로 리플레이
  - Gateway를 통해 들어온 요청을 기존 시스템에서 받아 응답한 후, Kafka를 통해 신규 시스템에 호출하여 응답값 비교
  - 결과를 주기적으로 리포팅, 다양한 엣지 케이스를 쉽게 발견
- Write Verifier
  - Write API 검증에 대한 오랜 고민
  - 신규 시스템에서 Write를 DB에 진행하고, 조회 진행 => 그리고 롤백함
    조회한 데이터는 Redis 에 저장
  - 이후 기존 시스템에서 Write 진행
    Write Verifier 에서 DB 및 Redis 데이터를 가져와서 비교하고 리포팅
  - Redis 가 아닌 DB 를 두는건? 테이블이 1000개이고, 롤백하는게 더 안전하다 생각함
  - 요청을 미리 처리해보고 롤백하는 방식
  - 동기식으로 동작하기 때문에 성능에 영향을 주어 개발환경에서만 사용
  - 검증을 위한 기능을 라이브러리로 제공
  - 결과를 실시간으로 리포팅
  - 정확한 검증으로 안전성 향상

- 레거시 시스템에서 발생하는 데이터를 기반으로 안정성을 보장하는데 집중
- 총 182개의 API 검증
- 테스트 시간을 효과적으로 절약

### 생애 주기가 긴 대출 상품
- 대출 상품의 경우, 10년 약정도 있는데 10년동안 서비스가 잘 동작하는지 어떻게 알까?
- 테스트시스템으로 실행, 해지 등 이벤트는 정상적으로 테스트 가능, 다만 먼 미래의 기준 금리 변경에 따른 이벤트는 테스트가 어려웠음
  => 테스트 데이터를 조정하는것은 문제가됨
  => 
- 모놀리식 방식 장점 - 단일 서비스, 단일 데이터 베이스
  - 프레임 워크에서 사용하는 기준시간을 변경하여 테스트 가능
  - 실행되는 거래 종류 표준화
- 독립된 테스트 환경에서 시간을 바꿔가며, 거래 실행, 검증
- 독립된 테스트 환경 - agent 구조
  - kubernetes를 이용한 독립적인 시뮬레이션 환경 구축
  - sidecar 방식으로 같이 구동
  - k8s pod 별로 시뮬레이션 구동
- 디비 복사 구조, 스키마 & 기본 데이터
  - 전날 기준 테스트계, 운영계 디비 스키마 자동 적용
- 시뮬레이션용 DB에서 유저별 DB 를 또 복사하여 독립된 구조 사용
- 검증 - 검증 거래 : 거래 과정을 디비 값을 이용해 검증


## 토스가 오프라인 결제를 빠르고 안정적으로 혁신하는 방법 (FRONT)
> https://www.youtube.com/watch?v=wMKmr6AwEjk

### 하루에도 수십번 배포가 가능했던 이유, 
- 토스 POS, FRONT는 Electron 앱 사용, 배포에 오래걸리는 문제가 있음
- Native 영역이 아닌 WebView 영역만 배포하는 방법이 없을까?
  - WebView Bundle 사용
- 마이크로 프론트엔드 아키텍처 구성
- 크로스플랫폼 지원을 위해 Native 영역에 Android, IOS 개발하고 Web View와 Bridge 역할을 하는 API, BRIDGE 개발 (표준화된 인터페이스만 구현하여 공수가 크지 않았음)

### 안정적으로 수십만건의 결제 만들어내기
- 연결 안정성 : 유선 연결, 무선 연결
  : 유선 연결은 안정적이지 않음 (정전기 등으로 안될수 있음)
  : Toss Serial Port Protocol 구현
- WebSocket 연결을 사용했음, 다만 IP 가 필요함
   Broadcasting 을 통해 토스 프론트의 IP 변경시, 토스 프론트가 토스 포스로 전달함

- 한가지가 아닌 여러가지 일을 하고 있는 결제코드, 분기가 많고 복잡해 버그가 발생할 가능성이 높음
- 코드를 시점에 따른 동일 관심사별로 분리 : 주문 전, 주문 후, 결재 후
- 시점에 따라 관심사를 분리하다 보니, 결제의 라이프사이클을 정의할 수 있게 됨
- 플러그인을 통해 사용하는곳에서 플러그인을 가져와서 사용만 하면 됨, 결제 핵심 로직과 분리해 복잡도를 낮춤, 결제에 새로운 부가기능이 생겨도 결제 핵심 로직에 영향을 주지 않기 떄문에 안전하게 배포 가능


# 빠르게 성장하고 싶은 주니어 개발자를 위한 소프트 스킬 5가지
> https://www.youtube.com/watch?v=JyAiWo4ghVg

- 하드스킬 : 프로그래밍, 트러블 슈팅 /. 소프트 스킬 : 커뮤니케이션, 시간 관리, 문제해결 능력
- 하드 스킬이 성장의 더하기라면 소프트 스킬은 곱하기
- 소프트스킬 5가지
  - 그림으로 소통하기 
    - 다이그램 툴 하나를 정해서 익숙해지자 (notion - whimsical)
  - 나만의 TODO List 만들기
    - Google Task : Today, Weekly, Monthly, Yearly
  - 코드를 보는 안목 기르기
  - 왜?라고 묻기
    - 내가 요청할때도 상대방이 "왜?"를 쉽게 알 수 있도록 합니다.
  - 나만의 개발 공부법 찾기

# 오픈소스로 Hadoop 클러스터 구축하기
> https://www.youtube.com/watch?v=4BcSVF4bLtU

- Apache Ambari : 하둡 에코 시스템의 설치, 설정 배포, 모니터링 등의 운영 편의성을 제공하는 도구
- 오픈소스는 git 히스토리까지 그대로 가져와야 좋음 (의존성 관계 등이 알기 어려움)
- 가져온 소스 커스텀을 하기보다는 실제 오픈소스에 기여하는 방식의 관리하기 좋음
  - 내부소스 고치고, 오픈소스에 기여하는 방식으로 개발했음

# CPU Observability 높이는 Hyperthread 톺아보기
> https://www.youtube.com/watch?v=8xhVvn7Q8-I

- pipeline, out of order, super scalar
- 코어를 쪼개고 압축해서 사용한다. 무조건 사용하면 좋은것이 아닌가?
- 문제점 :
  - Noisy Neighbor : 형제 프로세스가 자원을 점유하면 문제가 생길 수 있다.
  - 악의적인 사용자가 형제 프로세스 리소스를 가로채는것을 방지하기 위해 overhead 과정이 있음
- 성능 측정을 위해 CPU usage 는 노이즈가 있으니 Instruction 기준으로 처리량을 판단함
  - Linux-KI , perf
- 성능 측정 후, 하이퍼쓰레드 사용이 무조건 성능이 좋았음 다만 자원 경합으로 인한 stall 증가 모니터링이 필요함


# Next 코어뱅킹, MSA와 MySQL로 여는 평생 무료 환전 시대
> https://www.youtube.com/watch?v=uWnAVYgCd0k

- 코어뱅킹이 모놀리식으로 구성되어 있어서 MSA로 전환함
- 여전히 DB만은 Oracle 의존적인 코어뱅킹 아키텍처
- 왜 모든 은행은 Oracle만 사용하고 있을까?
  - 장점
    - 신뢰성과 안정성 : 트랜잭션 관리, 고가용성, 복구기능, 데이터 무결성 보장
    - 확장성, 성능, 오랜기간 축적된 노하우
  - 단점
    - SPOF (Single Point Of Failure), 비싼 비용, 제한적인 Scale-out
- 대체 배경
  - 트랜잭션 관리의 진화 : Redis 분산락, Kafka 활용한 SAGA 패턴
  - 확장성 : MySQL Repolication 전략
  - 안정성 : MySQL MVCC 기술
- 동시성 제어를 위해 Redis 분산락을 사용, DB에서는 비관적 Lock 을 사용
- 24/365 무중단 환전 서비스 구현 방법
- 테스트 자동화
  - Local : 단위 테스트, DEV : E2E 테스트 활용, Live : 이상거래탐지 서비스 개발 (데이터 완결성 검증)
  


# 알아보면 좋을것
P6SPY, ANTLR 을 통해 쿼리 추출을 진행했다는데, 어떻게 한걸까? (서비스 쿼리 추출에 사용?)

