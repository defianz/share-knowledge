# 능동적 읽기
- 복잡하거나 엉망인 코드를 읽고 이해하려 할때, 리팩토링 하면서 읽기
  -> 공백으로 단락 구분하기
  -> 메서드와 객체로 추상화 해보기
  -> 주석으로 이해한 내용 표기하며 읽기
- 우리에게는 언제든 돌아갈 수 있는 git reset --hard 가 있다.
- 핵심 목표는 우리의 도메인 지식을 늘리는 것.
  그리고 이전 작성자의 의도를 파악하는 것.

# 오버 엔지니어링
- 필요한 적정 수준보다 더 높은 수준의 엔지니어링
  -> ex) 구현체가 하나인 인터페이스
    - 인터페이스 형태가 아키텍처 이해에 도움을 주거나, 근시일 내에 구현체가 추가될 가능성이 높다면 OK.
    - 구현체를 수정할 때마다 인터페이스도 수정해야 함
    - 코드 탐색에 영향을 줌. 애플리케이션이 비대해 짐.

  -> ex) 너무 이른 추상화
    - 정보가 숨겨지기 때문에 복잡도가 높아진다.
    - 후대 개발자들이 선대의 의도를 파악하기가 어렵다.


# 은탄환은 없다
- 만능해결사는 없다.
- 클린 코드도 은탄환이 아니다.
- 실무 : 2가지 사이의 줄다리기
  -> 지속 가능한 소프트웨어의 품질 VS 기술 부채를 안고 가는 빠른 결과물
  -> 대부분의 회사는 돈을 벌고 성장해야 하고, 시장에서 빠르게 살아남는 것이 목표다.
  -> 이런 경우에도, 클린 코드를 추구하지 말라는 것이 아니라, 미래 시점에 잘 고치도록 할 수 있는 코드 센스가 필요하다. 결국은, 클린 코드의 사고법을 기반으로 결정하는 것.
- 모든 기술과 방법론은 적정 기술의 범위 내에서 사용되어야 한다.
  -> ex) 당장 급하게 배포 나가야 하는데, 동료에게 style 관련된 리뷰를 주고 고치도록 강요하는 사람
- 도구라는 것은, 일단 그것을 한계까지 사용할 줄 아는 사람이 그것을 사용하지 말아야 할 때도 아는 법이다.
  -> 적정 수준을 알기 위해, 때로는 극단적으로 시도해보자.